// automatically generated by the FlatBuffers compiler, do not modify


// @generated

use core::mem;
use core::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::{EndianScalar, Follow};

#[allow(unused_imports, dead_code)]
pub mod jet_stream {

  use core::mem;
  use core::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::{EndianScalar, Follow};

#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_DELIVERY_MODE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_DELIVERY_MODE: u8 = 2;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_DELIVERY_MODE: [DeliveryMode; 3] = [
  DeliveryMode::Reliable,
  DeliveryMode::PartiallyReliable,
  DeliveryMode::BestEffort,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct DeliveryMode(pub u8);
#[allow(non_upper_case_globals)]
impl DeliveryMode {
  pub const Reliable: Self = Self(0);
  pub const PartiallyReliable: Self = Self(1);
  pub const BestEffort: Self = Self(2);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 2;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::Reliable,
    Self::PartiallyReliable,
    Self::BestEffort,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::Reliable => Some("Reliable"),
      Self::PartiallyReliable => Some("PartiallyReliable"),
      Self::BestEffort => Some("BestEffort"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for DeliveryMode {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for DeliveryMode {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for DeliveryMode {
    type Output = DeliveryMode;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for DeliveryMode {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for DeliveryMode {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for DeliveryMode {}
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MIN_MESSAGE_TYPE: u8 = 0;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
pub const ENUM_MAX_MESSAGE_TYPE: u8 = 9;
#[deprecated(since = "2.0.0", note = "Use associated constants instead. This will no longer be generated in 2021.")]
#[allow(non_camel_case_types)]
pub const ENUM_VALUES_MESSAGE_TYPE: [MessageType; 10] = [
  MessageType::NONE,
  MessageType::Header,
  MessageType::ClientHello,
  MessageType::ServerHello,
  MessageType::SessionConfig,
  MessageType::SessionTicket,
  MessageType::PathChallenge,
  MessageType::PathResponse,
  MessageType::StunBindingRequest,
  MessageType::StunBindingResponse,
];

#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Default)]
#[repr(transparent)]
pub struct MessageType(pub u8);
#[allow(non_upper_case_globals)]
impl MessageType {
  pub const NONE: Self = Self(0);
  pub const Header: Self = Self(1);
  pub const ClientHello: Self = Self(2);
  pub const ServerHello: Self = Self(3);
  pub const SessionConfig: Self = Self(4);
  pub const SessionTicket: Self = Self(5);
  pub const PathChallenge: Self = Self(6);
  pub const PathResponse: Self = Self(7);
  pub const StunBindingRequest: Self = Self(8);
  pub const StunBindingResponse: Self = Self(9);

  pub const ENUM_MIN: u8 = 0;
  pub const ENUM_MAX: u8 = 9;
  pub const ENUM_VALUES: &'static [Self] = &[
    Self::NONE,
    Self::Header,
    Self::ClientHello,
    Self::ServerHello,
    Self::SessionConfig,
    Self::SessionTicket,
    Self::PathChallenge,
    Self::PathResponse,
    Self::StunBindingRequest,
    Self::StunBindingResponse,
  ];
  /// Returns the variant's name or "" if unknown.
  pub fn variant_name(self) -> Option<&'static str> {
    match self {
      Self::NONE => Some("NONE"),
      Self::Header => Some("Header"),
      Self::ClientHello => Some("ClientHello"),
      Self::ServerHello => Some("ServerHello"),
      Self::SessionConfig => Some("SessionConfig"),
      Self::SessionTicket => Some("SessionTicket"),
      Self::PathChallenge => Some("PathChallenge"),
      Self::PathResponse => Some("PathResponse"),
      Self::StunBindingRequest => Some("StunBindingRequest"),
      Self::StunBindingResponse => Some("StunBindingResponse"),
      _ => None,
    }
  }
}
impl core::fmt::Debug for MessageType {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    if let Some(name) = self.variant_name() {
      f.write_str(name)
    } else {
      f.write_fmt(format_args!("<UNKNOWN {:?}>", self.0))
    }
  }
}
impl<'a> flatbuffers::Follow<'a> for MessageType {
  type Inner = Self;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    let b = unsafe { flatbuffers::read_scalar_at::<u8>(buf, loc) };
    Self(b)
  }
}

impl flatbuffers::Push for MessageType {
    type Output = MessageType;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        unsafe { flatbuffers::emplace_scalar::<u8>(dst, self.0); }
    }
}

impl flatbuffers::EndianScalar for MessageType {
  type Scalar = u8;
  #[inline]
  fn to_little_endian(self) -> u8 {
    self.0.to_le()
  }
  #[inline]
  #[allow(clippy::wrong_self_convention)]
  fn from_little_endian(v: u8) -> Self {
    let b = u8::from_le(v);
    Self(b)
  }
}

impl<'a> flatbuffers::Verifiable for MessageType {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    u8::run_verifier(v, pos)
  }
}

impl flatbuffers::SimpleToVerifyInSlice for MessageType {}
pub struct MessageTypeUnionTableOffset {}

// struct Bytes32, aligned to 1
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Bytes32(pub [u8; 32]);
impl Default for Bytes32 { 
  fn default() -> Self { 
    Self([0; 32])
  }
}
impl core::fmt::Debug for Bytes32 {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Bytes32")
      .field("data", &self.data())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Bytes32 {}
impl<'a> flatbuffers::Follow<'a> for Bytes32 {
  type Inner = &'a Bytes32;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    unsafe { <&'a Bytes32>::follow(buf, loc) }
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Bytes32 {
  type Inner = &'a Bytes32;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    unsafe { flatbuffers::follow_cast_ref::<Bytes32>(buf, loc) }
  }
}
impl<'b> flatbuffers::Push for Bytes32 {
    type Output = Bytes32;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = unsafe { ::core::slice::from_raw_parts(self as *const Bytes32 as *const u8, <Self as flatbuffers::Push>::size()) };
        dst.copy_from_slice(src);
    }
    #[inline]
    fn alignment() -> flatbuffers::PushAlignment {
        flatbuffers::PushAlignment::new(1)
    }
}

impl<'a> flatbuffers::Verifiable for Bytes32 {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Bytes32 {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    data: &[u8; 32],
  ) -> Self {
    let mut s = Self([0; 32]);
    s.set_data(data);
    s
  }

  pub fn data(&'a self) -> flatbuffers::Array<'a, u8, 32> {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid array in this slot
    unsafe { flatbuffers::Array::follow(&self.0, 0) }
  }

  pub fn set_data(&mut self, items: &[u8; 32]) {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid array in this slot
    unsafe { flatbuffers::emplace_scalar_array(&mut self.0, 0, items) };
  }

}

// struct Bytes12, aligned to 1
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Bytes12(pub [u8; 12]);
impl Default for Bytes12 { 
  fn default() -> Self { 
    Self([0; 12])
  }
}
impl core::fmt::Debug for Bytes12 {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Bytes12")
      .field("data", &self.data())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Bytes12 {}
impl<'a> flatbuffers::Follow<'a> for Bytes12 {
  type Inner = &'a Bytes12;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    unsafe { <&'a Bytes12>::follow(buf, loc) }
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Bytes12 {
  type Inner = &'a Bytes12;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    unsafe { flatbuffers::follow_cast_ref::<Bytes12>(buf, loc) }
  }
}
impl<'b> flatbuffers::Push for Bytes12 {
    type Output = Bytes12;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = unsafe { ::core::slice::from_raw_parts(self as *const Bytes12 as *const u8, <Self as flatbuffers::Push>::size()) };
        dst.copy_from_slice(src);
    }
    #[inline]
    fn alignment() -> flatbuffers::PushAlignment {
        flatbuffers::PushAlignment::new(1)
    }
}

impl<'a> flatbuffers::Verifiable for Bytes12 {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Bytes12 {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    data: &[u8; 12],
  ) -> Self {
    let mut s = Self([0; 12]);
    s.set_data(data);
    s
  }

  pub fn data(&'a self) -> flatbuffers::Array<'a, u8, 12> {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid array in this slot
    unsafe { flatbuffers::Array::follow(&self.0, 0) }
  }

  pub fn set_data(&mut self, items: &[u8; 12]) {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid array in this slot
    unsafe { flatbuffers::emplace_scalar_array(&mut self.0, 0, items) };
  }

}

// struct Bytes8, aligned to 1
#[repr(transparent)]
#[derive(Clone, Copy, PartialEq)]
pub struct Bytes8(pub [u8; 8]);
impl Default for Bytes8 { 
  fn default() -> Self { 
    Self([0; 8])
  }
}
impl core::fmt::Debug for Bytes8 {
  fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {
    f.debug_struct("Bytes8")
      .field("data", &self.data())
      .finish()
  }
}

impl flatbuffers::SimpleToVerifyInSlice for Bytes8 {}
impl<'a> flatbuffers::Follow<'a> for Bytes8 {
  type Inner = &'a Bytes8;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    unsafe { <&'a Bytes8>::follow(buf, loc) }
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Bytes8 {
  type Inner = &'a Bytes8;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    unsafe { flatbuffers::follow_cast_ref::<Bytes8>(buf, loc) }
  }
}
impl<'b> flatbuffers::Push for Bytes8 {
    type Output = Bytes8;
    #[inline]
    unsafe fn push(&self, dst: &mut [u8], _written_len: usize) {
        let src = unsafe { ::core::slice::from_raw_parts(self as *const Bytes8 as *const u8, <Self as flatbuffers::Push>::size()) };
        dst.copy_from_slice(src);
    }
    #[inline]
    fn alignment() -> flatbuffers::PushAlignment {
        flatbuffers::PushAlignment::new(1)
    }
}

impl<'a> flatbuffers::Verifiable for Bytes8 {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.in_buffer::<Self>(pos)
  }
}

impl<'a> Bytes8 {
  #[allow(clippy::too_many_arguments)]
  pub fn new(
    data: &[u8; 8],
  ) -> Self {
    let mut s = Self([0; 8]);
    s.set_data(data);
    s
  }

  pub fn data(&'a self) -> flatbuffers::Array<'a, u8, 8> {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid array in this slot
    unsafe { flatbuffers::Array::follow(&self.0, 0) }
  }

  pub fn set_data(&mut self, items: &[u8; 8]) {
    // Safety:
    // Created from a valid Table for this object
    // Which contains a valid array in this slot
    unsafe { flatbuffers::emplace_scalar_array(&mut self.0, 0, items) };
  }

}

pub enum HeaderOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Header<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Header<'a> {
  type Inner = Header<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Header<'a> {
  pub const VT_STREAM_ID: flatbuffers::VOffsetT = 4;
  pub const VT_MSG_TYPE: flatbuffers::VOffsetT = 6;
  pub const VT_FLAGS: flatbuffers::VOffsetT = 8;
  pub const VT_SEQUENCE: flatbuffers::VOffsetT = 10;
  pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 12;
  pub const VT_NONCE: flatbuffers::VOffsetT = 14;
  pub const VT_DELIVERY_MODE: flatbuffers::VOffsetT = 16;
  pub const VT_TTL_MS: flatbuffers::VOffsetT = 18;
  pub const VT_PIGGYBACKED_ACK: flatbuffers::VOffsetT = 20;
  pub const VT_PAYLOAD_LEN: flatbuffers::VOffsetT = 22;
  pub const VT_CONNECTION_ID: flatbuffers::VOffsetT = 24;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Header { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args HeaderArgs
  ) -> flatbuffers::WIPOffset<Header<'bldr>> {
    let mut builder = HeaderBuilder::new(_fbb);
    if let Some(x) = args.connection_id { builder.add_connection_id(x); }
    if let Some(x) = args.piggybacked_ack { builder.add_piggybacked_ack(x); }
    builder.add_nonce(args.nonce);
    builder.add_timestamp(args.timestamp);
    builder.add_sequence(args.sequence);
    if let Some(x) = args.payload_len { builder.add_payload_len(x); }
    builder.add_ttl_ms(args.ttl_ms);
    builder.add_stream_id(args.stream_id);
    builder.add_delivery_mode(args.delivery_mode);
    builder.add_flags(args.flags);
    builder.add_msg_type(args.msg_type);
    builder.finish()
  }


  #[inline]
  pub fn stream_id(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Header::VT_STREAM_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn msg_type(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(Header::VT_MSG_TYPE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn flags(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(Header::VT_FLAGS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn sequence(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Header::VT_SEQUENCE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn timestamp(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Header::VT_TIMESTAMP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn nonce(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Header::VT_NONCE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn delivery_mode(&self) -> DeliveryMode {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<DeliveryMode>(Header::VT_DELIVERY_MODE, Some(DeliveryMode::Reliable)).unwrap()}
  }
  #[inline]
  pub fn ttl_ms(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Header::VT_TTL_MS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn piggybacked_ack(&self) -> Option<u64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Header::VT_PIGGYBACKED_ACK, None)}
  }
  #[inline]
  pub fn payload_len(&self) -> Option<u32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(Header::VT_PAYLOAD_LEN, None)}
  }
  #[inline]
  pub fn connection_id(&self) -> Option<u64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(Header::VT_CONNECTION_ID, None)}
  }
}

impl flatbuffers::Verifiable for Header<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("stream_id", Self::VT_STREAM_ID, false)?
     .visit_field::<u8>("msg_type", Self::VT_MSG_TYPE, false)?
     .visit_field::<u8>("flags", Self::VT_FLAGS, false)?
     .visit_field::<u64>("sequence", Self::VT_SEQUENCE, false)?
     .visit_field::<u64>("timestamp", Self::VT_TIMESTAMP, false)?
     .visit_field::<u64>("nonce", Self::VT_NONCE, false)?
     .visit_field::<DeliveryMode>("delivery_mode", Self::VT_DELIVERY_MODE, false)?
     .visit_field::<u32>("ttl_ms", Self::VT_TTL_MS, false)?
     .visit_field::<u64>("piggybacked_ack", Self::VT_PIGGYBACKED_ACK, false)?
     .visit_field::<u32>("payload_len", Self::VT_PAYLOAD_LEN, false)?
     .visit_field::<u64>("connection_id", Self::VT_CONNECTION_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct HeaderArgs {
    pub stream_id: u32,
    pub msg_type: u8,
    pub flags: u8,
    pub sequence: u64,
    pub timestamp: u64,
    pub nonce: u64,
    pub delivery_mode: DeliveryMode,
    pub ttl_ms: u32,
    pub piggybacked_ack: Option<u64>,
    pub payload_len: Option<u32>,
    pub connection_id: Option<u64>,
}
impl<'a> Default for HeaderArgs {
  #[inline]
  fn default() -> Self {
    HeaderArgs {
      stream_id: 0,
      msg_type: 0,
      flags: 0,
      sequence: 0,
      timestamp: 0,
      nonce: 0,
      delivery_mode: DeliveryMode::Reliable,
      ttl_ms: 0,
      piggybacked_ack: None,
      payload_len: None,
      connection_id: None,
    }
  }
}

pub struct HeaderBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> HeaderBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_stream_id(&mut self, stream_id: u32) {
    self.fbb_.push_slot::<u32>(Header::VT_STREAM_ID, stream_id, 0);
  }
  #[inline]
  pub fn add_msg_type(&mut self, msg_type: u8) {
    self.fbb_.push_slot::<u8>(Header::VT_MSG_TYPE, msg_type, 0);
  }
  #[inline]
  pub fn add_flags(&mut self, flags: u8) {
    self.fbb_.push_slot::<u8>(Header::VT_FLAGS, flags, 0);
  }
  #[inline]
  pub fn add_sequence(&mut self, sequence: u64) {
    self.fbb_.push_slot::<u64>(Header::VT_SEQUENCE, sequence, 0);
  }
  #[inline]
  pub fn add_timestamp(&mut self, timestamp: u64) {
    self.fbb_.push_slot::<u64>(Header::VT_TIMESTAMP, timestamp, 0);
  }
  #[inline]
  pub fn add_nonce(&mut self, nonce: u64) {
    self.fbb_.push_slot::<u64>(Header::VT_NONCE, nonce, 0);
  }
  #[inline]
  pub fn add_delivery_mode(&mut self, delivery_mode: DeliveryMode) {
    self.fbb_.push_slot::<DeliveryMode>(Header::VT_DELIVERY_MODE, delivery_mode, DeliveryMode::Reliable);
  }
  #[inline]
  pub fn add_ttl_ms(&mut self, ttl_ms: u32) {
    self.fbb_.push_slot::<u32>(Header::VT_TTL_MS, ttl_ms, 0);
  }
  #[inline]
  pub fn add_piggybacked_ack(&mut self, piggybacked_ack: u64) {
    self.fbb_.push_slot_always::<u64>(Header::VT_PIGGYBACKED_ACK, piggybacked_ack);
  }
  #[inline]
  pub fn add_payload_len(&mut self, payload_len: u32) {
    self.fbb_.push_slot_always::<u32>(Header::VT_PAYLOAD_LEN, payload_len);
  }
  #[inline]
  pub fn add_connection_id(&mut self, connection_id: u64) {
    self.fbb_.push_slot_always::<u64>(Header::VT_CONNECTION_ID, connection_id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> HeaderBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    HeaderBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Header<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Header<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Header");
      ds.field("stream_id", &self.stream_id());
      ds.field("msg_type", &self.msg_type());
      ds.field("flags", &self.flags());
      ds.field("sequence", &self.sequence());
      ds.field("timestamp", &self.timestamp());
      ds.field("nonce", &self.nonce());
      ds.field("delivery_mode", &self.delivery_mode());
      ds.field("ttl_ms", &self.ttl_ms());
      ds.field("piggybacked_ack", &self.piggybacked_ack());
      ds.field("payload_len", &self.payload_len());
      ds.field("connection_id", &self.connection_id());
      ds.finish()
  }
}
pub enum ClientHelloOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ClientHello<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ClientHello<'a> {
  type Inner = ClientHello<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> ClientHello<'a> {
  pub const VT_VERSION: flatbuffers::VOffsetT = 4;
  pub const VT_CLIENT_RANDOM: flatbuffers::VOffsetT = 6;
  pub const VT_SESSION_ID: flatbuffers::VOffsetT = 8;
  pub const VT_SUPPORTED_CIPHERS: flatbuffers::VOffsetT = 10;
  pub const VT_X25519_PUBLIC_KEY: flatbuffers::VOffsetT = 12;
  pub const VT_KYBER_PUBLIC_KEY: flatbuffers::VOffsetT = 14;
  pub const VT_NONCE: flatbuffers::VOffsetT = 16;
  pub const VT_TIMESTAMP: flatbuffers::VOffsetT = 18;
  pub const VT_CONNECTION_ID: flatbuffers::VOffsetT = 20;
  pub const VT_SUPPORTED_FORMATS: flatbuffers::VOffsetT = 22;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ClientHello { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ClientHelloArgs<'args>
  ) -> flatbuffers::WIPOffset<ClientHello<'bldr>> {
    let mut builder = ClientHelloBuilder::new(_fbb);
    if let Some(x) = args.connection_id { builder.add_connection_id(x); }
    builder.add_timestamp(args.timestamp);
    builder.add_nonce(args.nonce);
    builder.add_session_id(args.session_id);
    if let Some(x) = args.supported_formats { builder.add_supported_formats(x); }
    if let Some(x) = args.kyber_public_key { builder.add_kyber_public_key(x); }
    if let Some(x) = args.x25519_public_key { builder.add_x25519_public_key(x); }
    if let Some(x) = args.supported_ciphers { builder.add_supported_ciphers(x); }
    if let Some(x) = args.client_random { builder.add_client_random(x); }
    builder.add_version(args.version);
    builder.finish()
  }


  #[inline]
  pub fn version(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(ClientHello::VT_VERSION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn client_random(&self) -> Option<&'a Bytes32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Bytes32>(ClientHello::VT_CLIENT_RANDOM, None)}
  }
  #[inline]
  pub fn session_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ClientHello::VT_SESSION_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn supported_ciphers(&self) -> Option<flatbuffers::Vector<'a, u16>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u16>>>(ClientHello::VT_SUPPORTED_CIPHERS, None)}
  }
  #[inline]
  pub fn x25519_public_key(&self) -> Option<&'a Bytes32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Bytes32>(ClientHello::VT_X25519_PUBLIC_KEY, None)}
  }
  #[inline]
  pub fn kyber_public_key(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(ClientHello::VT_KYBER_PUBLIC_KEY, None)}
  }
  #[inline]
  pub fn nonce(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ClientHello::VT_NONCE, Some(0)).unwrap()}
  }
  #[inline]
  pub fn timestamp(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ClientHello::VT_TIMESTAMP, Some(0)).unwrap()}
  }
  #[inline]
  pub fn connection_id(&self) -> Option<u64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ClientHello::VT_CONNECTION_ID, None)}
  }
  #[inline]
  pub fn supported_formats(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(ClientHello::VT_SUPPORTED_FORMATS, None)}
  }
}

impl flatbuffers::Verifiable for ClientHello<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("version", Self::VT_VERSION, false)?
     .visit_field::<Bytes32>("client_random", Self::VT_CLIENT_RANDOM, false)?
     .visit_field::<u64>("session_id", Self::VT_SESSION_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u16>>>("supported_ciphers", Self::VT_SUPPORTED_CIPHERS, false)?
     .visit_field::<Bytes32>("x25519_public_key", Self::VT_X25519_PUBLIC_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("kyber_public_key", Self::VT_KYBER_PUBLIC_KEY, false)?
     .visit_field::<u64>("nonce", Self::VT_NONCE, false)?
     .visit_field::<u64>("timestamp", Self::VT_TIMESTAMP, false)?
     .visit_field::<u64>("connection_id", Self::VT_CONNECTION_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("supported_formats", Self::VT_SUPPORTED_FORMATS, false)?
     .finish();
    Ok(())
  }
}
pub struct ClientHelloArgs<'a> {
    pub version: u16,
    pub client_random: Option<&'a Bytes32>,
    pub session_id: u64,
    pub supported_ciphers: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u16>>>,
    pub x25519_public_key: Option<&'a Bytes32>,
    pub kyber_public_key: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub nonce: u64,
    pub timestamp: u64,
    pub connection_id: Option<u64>,
    pub supported_formats: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for ClientHelloArgs<'a> {
  #[inline]
  fn default() -> Self {
    ClientHelloArgs {
      version: 0,
      client_random: None,
      session_id: 0,
      supported_ciphers: None,
      x25519_public_key: None,
      kyber_public_key: None,
      nonce: 0,
      timestamp: 0,
      connection_id: None,
      supported_formats: None,
    }
  }
}

pub struct ClientHelloBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ClientHelloBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_version(&mut self, version: u16) {
    self.fbb_.push_slot::<u16>(ClientHello::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_client_random(&mut self, client_random: &Bytes32) {
    self.fbb_.push_slot_always::<&Bytes32>(ClientHello::VT_CLIENT_RANDOM, client_random);
  }
  #[inline]
  pub fn add_session_id(&mut self, session_id: u64) {
    self.fbb_.push_slot::<u64>(ClientHello::VT_SESSION_ID, session_id, 0);
  }
  #[inline]
  pub fn add_supported_ciphers(&mut self, supported_ciphers: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u16>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ClientHello::VT_SUPPORTED_CIPHERS, supported_ciphers);
  }
  #[inline]
  pub fn add_x25519_public_key(&mut self, x25519_public_key: &Bytes32) {
    self.fbb_.push_slot_always::<&Bytes32>(ClientHello::VT_X25519_PUBLIC_KEY, x25519_public_key);
  }
  #[inline]
  pub fn add_kyber_public_key(&mut self, kyber_public_key: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ClientHello::VT_KYBER_PUBLIC_KEY, kyber_public_key);
  }
  #[inline]
  pub fn add_nonce(&mut self, nonce: u64) {
    self.fbb_.push_slot::<u64>(ClientHello::VT_NONCE, nonce, 0);
  }
  #[inline]
  pub fn add_timestamp(&mut self, timestamp: u64) {
    self.fbb_.push_slot::<u64>(ClientHello::VT_TIMESTAMP, timestamp, 0);
  }
  #[inline]
  pub fn add_connection_id(&mut self, connection_id: u64) {
    self.fbb_.push_slot_always::<u64>(ClientHello::VT_CONNECTION_ID, connection_id);
  }
  #[inline]
  pub fn add_supported_formats(&mut self, supported_formats: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ClientHello::VT_SUPPORTED_FORMATS, supported_formats);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ClientHelloBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ClientHelloBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ClientHello<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ClientHello<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ClientHello");
      ds.field("version", &self.version());
      ds.field("client_random", &self.client_random());
      ds.field("session_id", &self.session_id());
      ds.field("supported_ciphers", &self.supported_ciphers());
      ds.field("x25519_public_key", &self.x25519_public_key());
      ds.field("kyber_public_key", &self.kyber_public_key());
      ds.field("nonce", &self.nonce());
      ds.field("timestamp", &self.timestamp());
      ds.field("connection_id", &self.connection_id());
      ds.field("supported_formats", &self.supported_formats());
      ds.finish()
  }
}
pub enum ServerHelloOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct ServerHello<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for ServerHello<'a> {
  type Inner = ServerHello<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> ServerHello<'a> {
  pub const VT_VERSION: flatbuffers::VOffsetT = 4;
  pub const VT_SERVER_RANDOM: flatbuffers::VOffsetT = 6;
  pub const VT_SESSION_ID: flatbuffers::VOffsetT = 8;
  pub const VT_SELECTED_CIPHER: flatbuffers::VOffsetT = 10;
  pub const VT_X25519_PUBLIC_KEY: flatbuffers::VOffsetT = 12;
  pub const VT_KYBER_CIPHERTEXT: flatbuffers::VOffsetT = 14;
  pub const VT_CONNECTION_ID: flatbuffers::VOffsetT = 16;
  pub const VT_SELECTED_FORMAT: flatbuffers::VOffsetT = 18;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    ServerHello { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args ServerHelloArgs<'args>
  ) -> flatbuffers::WIPOffset<ServerHello<'bldr>> {
    let mut builder = ServerHelloBuilder::new(_fbb);
    if let Some(x) = args.connection_id { builder.add_connection_id(x); }
    builder.add_session_id(args.session_id);
    if let Some(x) = args.kyber_ciphertext { builder.add_kyber_ciphertext(x); }
    if let Some(x) = args.x25519_public_key { builder.add_x25519_public_key(x); }
    if let Some(x) = args.server_random { builder.add_server_random(x); }
    builder.add_selected_cipher(args.selected_cipher);
    builder.add_version(args.version);
    builder.add_selected_format(args.selected_format);
    builder.finish()
  }


  #[inline]
  pub fn version(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(ServerHello::VT_VERSION, Some(0)).unwrap()}
  }
  #[inline]
  pub fn server_random(&self) -> Option<&'a Bytes32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Bytes32>(ServerHello::VT_SERVER_RANDOM, None)}
  }
  #[inline]
  pub fn session_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ServerHello::VT_SESSION_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn selected_cipher(&self) -> u16 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u16>(ServerHello::VT_SELECTED_CIPHER, Some(0)).unwrap()}
  }
  #[inline]
  pub fn x25519_public_key(&self) -> Option<&'a Bytes32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Bytes32>(ServerHello::VT_X25519_PUBLIC_KEY, None)}
  }
  #[inline]
  pub fn kyber_ciphertext(&self) -> Option<flatbuffers::Vector<'a, u8>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(ServerHello::VT_KYBER_CIPHERTEXT, None)}
  }
  #[inline]
  pub fn connection_id(&self) -> Option<u64> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(ServerHello::VT_CONNECTION_ID, None)}
  }
  #[inline]
  pub fn selected_format(&self) -> u8 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u8>(ServerHello::VT_SELECTED_FORMAT, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for ServerHello<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u16>("version", Self::VT_VERSION, false)?
     .visit_field::<Bytes32>("server_random", Self::VT_SERVER_RANDOM, false)?
     .visit_field::<u64>("session_id", Self::VT_SESSION_ID, false)?
     .visit_field::<u16>("selected_cipher", Self::VT_SELECTED_CIPHER, false)?
     .visit_field::<Bytes32>("x25519_public_key", Self::VT_X25519_PUBLIC_KEY, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("kyber_ciphertext", Self::VT_KYBER_CIPHERTEXT, false)?
     .visit_field::<u64>("connection_id", Self::VT_CONNECTION_ID, false)?
     .visit_field::<u8>("selected_format", Self::VT_SELECTED_FORMAT, false)?
     .finish();
    Ok(())
  }
}
pub struct ServerHelloArgs<'a> {
    pub version: u16,
    pub server_random: Option<&'a Bytes32>,
    pub session_id: u64,
    pub selected_cipher: u16,
    pub x25519_public_key: Option<&'a Bytes32>,
    pub kyber_ciphertext: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
    pub connection_id: Option<u64>,
    pub selected_format: u8,
}
impl<'a> Default for ServerHelloArgs<'a> {
  #[inline]
  fn default() -> Self {
    ServerHelloArgs {
      version: 0,
      server_random: None,
      session_id: 0,
      selected_cipher: 0,
      x25519_public_key: None,
      kyber_ciphertext: None,
      connection_id: None,
      selected_format: 0,
    }
  }
}

pub struct ServerHelloBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> ServerHelloBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_version(&mut self, version: u16) {
    self.fbb_.push_slot::<u16>(ServerHello::VT_VERSION, version, 0);
  }
  #[inline]
  pub fn add_server_random(&mut self, server_random: &Bytes32) {
    self.fbb_.push_slot_always::<&Bytes32>(ServerHello::VT_SERVER_RANDOM, server_random);
  }
  #[inline]
  pub fn add_session_id(&mut self, session_id: u64) {
    self.fbb_.push_slot::<u64>(ServerHello::VT_SESSION_ID, session_id, 0);
  }
  #[inline]
  pub fn add_selected_cipher(&mut self, selected_cipher: u16) {
    self.fbb_.push_slot::<u16>(ServerHello::VT_SELECTED_CIPHER, selected_cipher, 0);
  }
  #[inline]
  pub fn add_x25519_public_key(&mut self, x25519_public_key: &Bytes32) {
    self.fbb_.push_slot_always::<&Bytes32>(ServerHello::VT_X25519_PUBLIC_KEY, x25519_public_key);
  }
  #[inline]
  pub fn add_kyber_ciphertext(&mut self, kyber_ciphertext: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(ServerHello::VT_KYBER_CIPHERTEXT, kyber_ciphertext);
  }
  #[inline]
  pub fn add_connection_id(&mut self, connection_id: u64) {
    self.fbb_.push_slot_always::<u64>(ServerHello::VT_CONNECTION_ID, connection_id);
  }
  #[inline]
  pub fn add_selected_format(&mut self, selected_format: u8) {
    self.fbb_.push_slot::<u8>(ServerHello::VT_SELECTED_FORMAT, selected_format, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> ServerHelloBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    ServerHelloBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<ServerHello<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for ServerHello<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("ServerHello");
      ds.field("version", &self.version());
      ds.field("server_random", &self.server_random());
      ds.field("session_id", &self.session_id());
      ds.field("selected_cipher", &self.selected_cipher());
      ds.field("x25519_public_key", &self.x25519_public_key());
      ds.field("kyber_ciphertext", &self.kyber_ciphertext());
      ds.field("connection_id", &self.connection_id());
      ds.field("selected_format", &self.selected_format());
      ds.finish()
  }
}
pub enum SessionConfigOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SessionConfig<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SessionConfig<'a> {
  type Inner = SessionConfig<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> SessionConfig<'a> {
  pub const VT_TIMEOUT_SECS: flatbuffers::VOffsetT = 4;
  pub const VT_MAX_STREAMS: flatbuffers::VOffsetT = 6;
  pub const VT_RATE_LIMIT_MESSAGES: flatbuffers::VOffsetT = 8;
  pub const VT_RATE_LIMIT_BYTES: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SessionConfig { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SessionConfigArgs
  ) -> flatbuffers::WIPOffset<SessionConfig<'bldr>> {
    let mut builder = SessionConfigBuilder::new(_fbb);
    builder.add_rate_limit_bytes(args.rate_limit_bytes);
    builder.add_rate_limit_messages(args.rate_limit_messages);
    builder.add_max_streams(args.max_streams);
    builder.add_timeout_secs(args.timeout_secs);
    builder.finish()
  }


  #[inline]
  pub fn timeout_secs(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(SessionConfig::VT_TIMEOUT_SECS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn max_streams(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(SessionConfig::VT_MAX_STREAMS, Some(0)).unwrap()}
  }
  #[inline]
  pub fn rate_limit_messages(&self) -> u32 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u32>(SessionConfig::VT_RATE_LIMIT_MESSAGES, Some(0)).unwrap()}
  }
  #[inline]
  pub fn rate_limit_bytes(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(SessionConfig::VT_RATE_LIMIT_BYTES, Some(0)).unwrap()}
  }
}

impl flatbuffers::Verifiable for SessionConfig<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u32>("timeout_secs", Self::VT_TIMEOUT_SECS, false)?
     .visit_field::<u32>("max_streams", Self::VT_MAX_STREAMS, false)?
     .visit_field::<u32>("rate_limit_messages", Self::VT_RATE_LIMIT_MESSAGES, false)?
     .visit_field::<u64>("rate_limit_bytes", Self::VT_RATE_LIMIT_BYTES, false)?
     .finish();
    Ok(())
  }
}
pub struct SessionConfigArgs {
    pub timeout_secs: u32,
    pub max_streams: u32,
    pub rate_limit_messages: u32,
    pub rate_limit_bytes: u64,
}
impl<'a> Default for SessionConfigArgs {
  #[inline]
  fn default() -> Self {
    SessionConfigArgs {
      timeout_secs: 0,
      max_streams: 0,
      rate_limit_messages: 0,
      rate_limit_bytes: 0,
    }
  }
}

pub struct SessionConfigBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SessionConfigBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_timeout_secs(&mut self, timeout_secs: u32) {
    self.fbb_.push_slot::<u32>(SessionConfig::VT_TIMEOUT_SECS, timeout_secs, 0);
  }
  #[inline]
  pub fn add_max_streams(&mut self, max_streams: u32) {
    self.fbb_.push_slot::<u32>(SessionConfig::VT_MAX_STREAMS, max_streams, 0);
  }
  #[inline]
  pub fn add_rate_limit_messages(&mut self, rate_limit_messages: u32) {
    self.fbb_.push_slot::<u32>(SessionConfig::VT_RATE_LIMIT_MESSAGES, rate_limit_messages, 0);
  }
  #[inline]
  pub fn add_rate_limit_bytes(&mut self, rate_limit_bytes: u64) {
    self.fbb_.push_slot::<u64>(SessionConfig::VT_RATE_LIMIT_BYTES, rate_limit_bytes, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SessionConfigBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SessionConfigBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SessionConfig<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SessionConfig<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SessionConfig");
      ds.field("timeout_secs", &self.timeout_secs());
      ds.field("max_streams", &self.max_streams());
      ds.field("rate_limit_messages", &self.rate_limit_messages());
      ds.field("rate_limit_bytes", &self.rate_limit_bytes());
      ds.finish()
  }
}
pub enum SessionTicketOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct SessionTicket<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for SessionTicket<'a> {
  type Inner = SessionTicket<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> SessionTicket<'a> {
  pub const VT_TICKET_ID: flatbuffers::VOffsetT = 4;
  pub const VT_CREATED_AT: flatbuffers::VOffsetT = 6;
  pub const VT_EXPIRES_AT: flatbuffers::VOffsetT = 8;
  pub const VT_SESSION_KEY: flatbuffers::VOffsetT = 10;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    SessionTicket { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args SessionTicketArgs<'args>
  ) -> flatbuffers::WIPOffset<SessionTicket<'bldr>> {
    let mut builder = SessionTicketBuilder::new(_fbb);
    builder.add_expires_at(args.expires_at);
    builder.add_created_at(args.created_at);
    builder.add_ticket_id(args.ticket_id);
    if let Some(x) = args.session_key { builder.add_session_key(x); }
    builder.finish()
  }


  #[inline]
  pub fn ticket_id(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(SessionTicket::VT_TICKET_ID, Some(0)).unwrap()}
  }
  #[inline]
  pub fn created_at(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(SessionTicket::VT_CREATED_AT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn expires_at(&self) -> u64 {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<u64>(SessionTicket::VT_EXPIRES_AT, Some(0)).unwrap()}
  }
  #[inline]
  pub fn session_key(&self) -> Option<&'a Bytes32> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Bytes32>(SessionTicket::VT_SESSION_KEY, None)}
  }
}

impl flatbuffers::Verifiable for SessionTicket<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<u64>("ticket_id", Self::VT_TICKET_ID, false)?
     .visit_field::<u64>("created_at", Self::VT_CREATED_AT, false)?
     .visit_field::<u64>("expires_at", Self::VT_EXPIRES_AT, false)?
     .visit_field::<Bytes32>("session_key", Self::VT_SESSION_KEY, false)?
     .finish();
    Ok(())
  }
}
pub struct SessionTicketArgs<'a> {
    pub ticket_id: u64,
    pub created_at: u64,
    pub expires_at: u64,
    pub session_key: Option<&'a Bytes32>,
}
impl<'a> Default for SessionTicketArgs<'a> {
  #[inline]
  fn default() -> Self {
    SessionTicketArgs {
      ticket_id: 0,
      created_at: 0,
      expires_at: 0,
      session_key: None,
    }
  }
}

pub struct SessionTicketBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> SessionTicketBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_ticket_id(&mut self, ticket_id: u64) {
    self.fbb_.push_slot::<u64>(SessionTicket::VT_TICKET_ID, ticket_id, 0);
  }
  #[inline]
  pub fn add_created_at(&mut self, created_at: u64) {
    self.fbb_.push_slot::<u64>(SessionTicket::VT_CREATED_AT, created_at, 0);
  }
  #[inline]
  pub fn add_expires_at(&mut self, expires_at: u64) {
    self.fbb_.push_slot::<u64>(SessionTicket::VT_EXPIRES_AT, expires_at, 0);
  }
  #[inline]
  pub fn add_session_key(&mut self, session_key: &Bytes32) {
    self.fbb_.push_slot_always::<&Bytes32>(SessionTicket::VT_SESSION_KEY, session_key);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> SessionTicketBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    SessionTicketBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<SessionTicket<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for SessionTicket<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("SessionTicket");
      ds.field("ticket_id", &self.ticket_id());
      ds.field("created_at", &self.created_at());
      ds.field("expires_at", &self.expires_at());
      ds.field("session_key", &self.session_key());
      ds.finish()
  }
}
pub enum PathChallengeOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PathChallenge<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PathChallenge<'a> {
  type Inner = PathChallenge<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> PathChallenge<'a> {
  pub const VT_CHALLENGE_DATA: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PathChallenge { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PathChallengeArgs<'args>
  ) -> flatbuffers::WIPOffset<PathChallenge<'bldr>> {
    let mut builder = PathChallengeBuilder::new(_fbb);
    if let Some(x) = args.challenge_data { builder.add_challenge_data(x); }
    builder.finish()
  }


  #[inline]
  pub fn challenge_data(&self) -> Option<&'a Bytes8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Bytes8>(PathChallenge::VT_CHALLENGE_DATA, None)}
  }
}

impl flatbuffers::Verifiable for PathChallenge<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Bytes8>("challenge_data", Self::VT_CHALLENGE_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct PathChallengeArgs<'a> {
    pub challenge_data: Option<&'a Bytes8>,
}
impl<'a> Default for PathChallengeArgs<'a> {
  #[inline]
  fn default() -> Self {
    PathChallengeArgs {
      challenge_data: None,
    }
  }
}

pub struct PathChallengeBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PathChallengeBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_challenge_data(&mut self, challenge_data: &Bytes8) {
    self.fbb_.push_slot_always::<&Bytes8>(PathChallenge::VT_CHALLENGE_DATA, challenge_data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PathChallengeBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PathChallengeBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PathChallenge<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PathChallenge<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PathChallenge");
      ds.field("challenge_data", &self.challenge_data());
      ds.finish()
  }
}
pub enum PathResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct PathResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for PathResponse<'a> {
  type Inner = PathResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> PathResponse<'a> {
  pub const VT_CHALLENGE_DATA: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    PathResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args PathResponseArgs<'args>
  ) -> flatbuffers::WIPOffset<PathResponse<'bldr>> {
    let mut builder = PathResponseBuilder::new(_fbb);
    if let Some(x) = args.challenge_data { builder.add_challenge_data(x); }
    builder.finish()
  }


  #[inline]
  pub fn challenge_data(&self) -> Option<&'a Bytes8> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Bytes8>(PathResponse::VT_CHALLENGE_DATA, None)}
  }
}

impl flatbuffers::Verifiable for PathResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Bytes8>("challenge_data", Self::VT_CHALLENGE_DATA, false)?
     .finish();
    Ok(())
  }
}
pub struct PathResponseArgs<'a> {
    pub challenge_data: Option<&'a Bytes8>,
}
impl<'a> Default for PathResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    PathResponseArgs {
      challenge_data: None,
    }
  }
}

pub struct PathResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> PathResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_challenge_data(&mut self, challenge_data: &Bytes8) {
    self.fbb_.push_slot_always::<&Bytes8>(PathResponse::VT_CHALLENGE_DATA, challenge_data);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> PathResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    PathResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<PathResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for PathResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("PathResponse");
      ds.field("challenge_data", &self.challenge_data());
      ds.finish()
  }
}
pub enum StunBindingRequestOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StunBindingRequest<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StunBindingRequest<'a> {
  type Inner = StunBindingRequest<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> StunBindingRequest<'a> {
  pub const VT_TRANSACTION_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StunBindingRequest { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StunBindingRequestArgs<'args>
  ) -> flatbuffers::WIPOffset<StunBindingRequest<'bldr>> {
    let mut builder = StunBindingRequestBuilder::new(_fbb);
    if let Some(x) = args.transaction_id { builder.add_transaction_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn transaction_id(&self) -> Option<&'a Bytes12> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Bytes12>(StunBindingRequest::VT_TRANSACTION_ID, None)}
  }
}

impl flatbuffers::Verifiable for StunBindingRequest<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Bytes12>("transaction_id", Self::VT_TRANSACTION_ID, false)?
     .finish();
    Ok(())
  }
}
pub struct StunBindingRequestArgs<'a> {
    pub transaction_id: Option<&'a Bytes12>,
}
impl<'a> Default for StunBindingRequestArgs<'a> {
  #[inline]
  fn default() -> Self {
    StunBindingRequestArgs {
      transaction_id: None,
    }
  }
}

pub struct StunBindingRequestBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StunBindingRequestBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_transaction_id(&mut self, transaction_id: &Bytes12) {
    self.fbb_.push_slot_always::<&Bytes12>(StunBindingRequest::VT_TRANSACTION_ID, transaction_id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StunBindingRequestBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StunBindingRequestBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StunBindingRequest<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StunBindingRequest<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StunBindingRequest");
      ds.field("transaction_id", &self.transaction_id());
      ds.finish()
  }
}
pub enum StunBindingResponseOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct StunBindingResponse<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StunBindingResponse<'a> {
  type Inner = StunBindingResponse<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> StunBindingResponse<'a> {
  pub const VT_TRANSACTION_ID: flatbuffers::VOffsetT = 4;
  pub const VT_MAPPED_ADDRESS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    StunBindingResponse { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args StunBindingResponseArgs<'args>
  ) -> flatbuffers::WIPOffset<StunBindingResponse<'bldr>> {
    let mut builder = StunBindingResponseBuilder::new(_fbb);
    if let Some(x) = args.mapped_address { builder.add_mapped_address(x); }
    if let Some(x) = args.transaction_id { builder.add_transaction_id(x); }
    builder.finish()
  }


  #[inline]
  pub fn transaction_id(&self) -> Option<&'a Bytes12> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<Bytes12>(StunBindingResponse::VT_TRANSACTION_ID, None)}
  }
  #[inline]
  pub fn mapped_address(&self) -> Option<&'a str> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(StunBindingResponse::VT_MAPPED_ADDRESS, None)}
  }
}

impl flatbuffers::Verifiable for StunBindingResponse<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Bytes12>("transaction_id", Self::VT_TRANSACTION_ID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("mapped_address", Self::VT_MAPPED_ADDRESS, false)?
     .finish();
    Ok(())
  }
}
pub struct StunBindingResponseArgs<'a> {
    pub transaction_id: Option<&'a Bytes12>,
    pub mapped_address: Option<flatbuffers::WIPOffset<&'a str>>,
}
impl<'a> Default for StunBindingResponseArgs<'a> {
  #[inline]
  fn default() -> Self {
    StunBindingResponseArgs {
      transaction_id: None,
      mapped_address: None,
    }
  }
}

pub struct StunBindingResponseBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> StunBindingResponseBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_transaction_id(&mut self, transaction_id: &Bytes12) {
    self.fbb_.push_slot_always::<&Bytes12>(StunBindingResponse::VT_TRANSACTION_ID, transaction_id);
  }
  #[inline]
  pub fn add_mapped_address(&mut self, mapped_address: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StunBindingResponse::VT_MAPPED_ADDRESS, mapped_address);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> StunBindingResponseBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    StunBindingResponseBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StunBindingResponse<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for StunBindingResponse<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("StunBindingResponse");
      ds.field("transaction_id", &self.transaction_id());
      ds.field("mapped_address", &self.mapped_address());
      ds.finish()
  }
}
pub enum MessageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Message<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Message<'a> {
  type Inner = Message<'a>;
  #[inline]
  unsafe fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: unsafe { flatbuffers::Table::new(buf, loc) } }
  }
}

impl<'a> Message<'a> {
  pub const VT_MESSAGE_TYPE: flatbuffers::VOffsetT = 4;
  pub const VT_MESSAGE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub unsafe fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Message { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr, A: flatbuffers::Allocator + 'bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr, A>,
    args: &'args MessageArgs
  ) -> flatbuffers::WIPOffset<Message<'bldr>> {
    let mut builder = MessageBuilder::new(_fbb);
    if let Some(x) = args.message { builder.add_message(x); }
    builder.add_message_type(args.message_type);
    builder.finish()
  }


  #[inline]
  pub fn message_type(&self) -> MessageType {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<MessageType>(Message::VT_MESSAGE_TYPE, Some(MessageType::NONE)).unwrap()}
  }
  #[inline]
  pub fn message(&self) -> Option<flatbuffers::Table<'a>> {
    // Safety:
    // Created from valid Table for this object
    // which contains a valid value in this slot
    unsafe { self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Message::VT_MESSAGE, None)}
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_header(&self) -> Option<Header<'a>> {
    if self.message_type() == MessageType::Header {
      self.message().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { Header::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_client_hello(&self) -> Option<ClientHello<'a>> {
    if self.message_type() == MessageType::ClientHello {
      self.message().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ClientHello::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_server_hello(&self) -> Option<ServerHello<'a>> {
    if self.message_type() == MessageType::ServerHello {
      self.message().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { ServerHello::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_session_config(&self) -> Option<SessionConfig<'a>> {
    if self.message_type() == MessageType::SessionConfig {
      self.message().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SessionConfig::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_session_ticket(&self) -> Option<SessionTicket<'a>> {
    if self.message_type() == MessageType::SessionTicket {
      self.message().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { SessionTicket::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_path_challenge(&self) -> Option<PathChallenge<'a>> {
    if self.message_type() == MessageType::PathChallenge {
      self.message().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { PathChallenge::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_path_response(&self) -> Option<PathResponse<'a>> {
    if self.message_type() == MessageType::PathResponse {
      self.message().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { PathResponse::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_stun_binding_request(&self) -> Option<StunBindingRequest<'a>> {
    if self.message_type() == MessageType::StunBindingRequest {
      self.message().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { StunBindingRequest::init_from_table(t) }
     })
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_stun_binding_response(&self) -> Option<StunBindingResponse<'a>> {
    if self.message_type() == MessageType::StunBindingResponse {
      self.message().map(|t| {
       // Safety:
       // Created from a valid Table for this object
       // Which contains a valid union in this slot
       unsafe { StunBindingResponse::init_from_table(t) }
     })
    } else {
      None
    }
  }

}

impl flatbuffers::Verifiable for Message<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_union::<MessageType, _>("message_type", Self::VT_MESSAGE_TYPE, "message", Self::VT_MESSAGE, false, |key, v, pos| {
        match key {
          MessageType::Header => v.verify_union_variant::<flatbuffers::ForwardsUOffset<Header>>("MessageType::Header", pos),
          MessageType::ClientHello => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ClientHello>>("MessageType::ClientHello", pos),
          MessageType::ServerHello => v.verify_union_variant::<flatbuffers::ForwardsUOffset<ServerHello>>("MessageType::ServerHello", pos),
          MessageType::SessionConfig => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SessionConfig>>("MessageType::SessionConfig", pos),
          MessageType::SessionTicket => v.verify_union_variant::<flatbuffers::ForwardsUOffset<SessionTicket>>("MessageType::SessionTicket", pos),
          MessageType::PathChallenge => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PathChallenge>>("MessageType::PathChallenge", pos),
          MessageType::PathResponse => v.verify_union_variant::<flatbuffers::ForwardsUOffset<PathResponse>>("MessageType::PathResponse", pos),
          MessageType::StunBindingRequest => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StunBindingRequest>>("MessageType::StunBindingRequest", pos),
          MessageType::StunBindingResponse => v.verify_union_variant::<flatbuffers::ForwardsUOffset<StunBindingResponse>>("MessageType::StunBindingResponse", pos),
          _ => Ok(()),
        }
     })?
     .finish();
    Ok(())
  }
}
pub struct MessageArgs {
    pub message_type: MessageType,
    pub message: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for MessageArgs {
  #[inline]
  fn default() -> Self {
    MessageArgs {
      message_type: MessageType::NONE,
      message: None,
    }
  }
}

pub struct MessageBuilder<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b, A: flatbuffers::Allocator + 'a> MessageBuilder<'a, 'b, A> {
  #[inline]
  pub fn add_message_type(&mut self, message_type: MessageType) {
    self.fbb_.push_slot::<MessageType>(Message::VT_MESSAGE_TYPE, message_type, MessageType::NONE);
  }
  #[inline]
  pub fn add_message(&mut self, message: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_MESSAGE, message);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>) -> MessageBuilder<'a, 'b, A> {
    let start = _fbb.start_table();
    MessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Message<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl core::fmt::Debug for Message<'_> {
  fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
    let mut ds = f.debug_struct("Message");
      ds.field("message_type", &self.message_type());
      match self.message_type() {
        MessageType::Header => {
          if let Some(x) = self.message_as_header() {
            ds.field("message", &x)
          } else {
            ds.field("message", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MessageType::ClientHello => {
          if let Some(x) = self.message_as_client_hello() {
            ds.field("message", &x)
          } else {
            ds.field("message", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MessageType::ServerHello => {
          if let Some(x) = self.message_as_server_hello() {
            ds.field("message", &x)
          } else {
            ds.field("message", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MessageType::SessionConfig => {
          if let Some(x) = self.message_as_session_config() {
            ds.field("message", &x)
          } else {
            ds.field("message", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MessageType::SessionTicket => {
          if let Some(x) = self.message_as_session_ticket() {
            ds.field("message", &x)
          } else {
            ds.field("message", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MessageType::PathChallenge => {
          if let Some(x) = self.message_as_path_challenge() {
            ds.field("message", &x)
          } else {
            ds.field("message", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MessageType::PathResponse => {
          if let Some(x) = self.message_as_path_response() {
            ds.field("message", &x)
          } else {
            ds.field("message", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MessageType::StunBindingRequest => {
          if let Some(x) = self.message_as_stun_binding_request() {
            ds.field("message", &x)
          } else {
            ds.field("message", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        MessageType::StunBindingResponse => {
          if let Some(x) = self.message_as_stun_binding_response() {
            ds.field("message", &x)
          } else {
            ds.field("message", &"InvalidFlatbuffer: Union discriminant does not match value.")
          }
        },
        _ => {
          let x: Option<()> = None;
          ds.field("message", &x)
        },
      };
      ds.finish()
  }
}
#[inline]
/// Verifies that a buffer of bytes contains a `Message`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_message_unchecked`.
pub fn root_as_message(buf: &[u8]) -> Result<Message<'_>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Message>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Message` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_message_unchecked`.
pub fn size_prefixed_root_as_message(buf: &[u8]) -> Result<Message<'_>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Message>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Message` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_message_unchecked`.
pub fn root_as_message_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Message<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Message<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Message` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_message_unchecked`.
pub fn size_prefixed_root_as_message_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Message<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Message<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Message and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Message`.
pub unsafe fn root_as_message_unchecked(buf: &[u8]) -> Message<'_> {
  unsafe { flatbuffers::root_unchecked::<Message>(buf) }
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Message and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Message`.
pub unsafe fn size_prefixed_root_as_message_unchecked(buf: &[u8]) -> Message<'_> {
  unsafe { flatbuffers::size_prefixed_root_unchecked::<Message>(buf) }
}
#[inline]
pub fn finish_message_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>,
    root: flatbuffers::WIPOffset<Message<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_message_buffer<'a, 'b, A: flatbuffers::Allocator + 'a>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a, A>, root: flatbuffers::WIPOffset<Message<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod JetStream

